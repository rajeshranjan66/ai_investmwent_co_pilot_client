# utils/pdf_export.py
import os
from fpdf import FPDF
import pdfkit
import markdown2
from pylatex import Document, NoEscape
from utils.latex_check import is_latex
import markdown2
from weasyprint import HTML
import tempfile
import streamlit as st

def create_pdf_from_markdown(content: str) -> bytes:
    html_content = markdown2.markdown(content)
    pdf_bytes = HTML(string=html_content).write_pdf()
    return pdf_bytes

def create_pdf_from_latex(content: str) -> bytes:
    doc = Document()
    doc.preamble.append(NoEscape(r'\usepackage{amsmath}'))
    doc.append(NoEscape(content))
    with tempfile.TemporaryDirectory() as tmpdir:
        try:
            doc.generate_pdf(filepath=f"{tmpdir}/output", clean_tex=True)
        except Exception as e:
            log_path = f"{tmpdir}/output.log"
            if os.path.exists(log_path):
                with open(log_path) as logf:
                    print("=================",logf.read())
            raise e
        with open(f"{tmpdir}/output.pdf", "rb") as f:
            pdf_bytes = f.read()
    return pdf_bytes

def create_pdf(content: str) -> bytes:
    if is_latex(content):
        return create_pdf_from_latex(content)
    else:
        return create_pdf_from_markdown(content)
# def create_pdf(content: str) -> bytes:
#     pdf = FPDF()
#     pdf.add_page()
#     pdf.set_font("Arial", size=12)
#     for line in content.split('\n'):
#         pdf.multi_cell(0, 10, line)
#     #pdf_bytes = pdf.output(dest='S').encode('utf-8')
#     pdf_bytes = pdf.output(dest='S').encode('latin1')
#     print(f"PDF bytes created with length: {len(pdf_bytes)}")
#     print("PDF content preview (first 100 bytes):", pdf_bytes[:100])  # Preview first 100 bytes
#     return pdf_bytes

import uuid

def is_table_content(content: str) -> bool:
    import re
    # Detects a table by looking for a header line (e.g. "Asset\t...")
    return bool(re.search(r'^Asset\t', content, re.MULTILINE))

import uuid

def render_pdf_download(content, filename="Stock_Analysis", key=None, user_query=None):
    # Generate a unique filename
    unique_id = uuid.uuid4().hex[:8]
    base, ext = os.path.splitext(filename)
    filename = f"{base}_{unique_id}{ext or '.pdf'}"

    if content:
        try:
            # Add enhanced formatting
            if user_query:
                pdf_content = (
                    f"# User Query\n"
                    f"{user_query}\n"
                    
                    "# Agent Response\n"
                    f"{content}\n"
                    "******************\n"
                    #"---\n"
                    "### Additional Notes\n"
                    "<small>"
                    "This document was generated automatically.\n"
                    f"Generated on : {st.session_state.get('last_message_time', '')}\n"
                    "Generated by : Stock Analysis-DeepAgent\n"
                    f"Document name: {filename}\n"
                    "Version: 1.0\n"
                    "</small>"

                )
            else:
                pdf_content = content

            #pdf_bytes = create_pdf(pdf_content)
                # Detect table and use appropriate PDF creation
            if is_table_content(content):
                pdf_bytes = create_pdf_from_table_text(content)
            else:
                pdf_bytes = create_pdf(pdf_content)
            st.markdown(
                """
                <div style="display: flex; justify-content: center; align-items: center;">
                """,
                unsafe_allow_html=True
            )
            st.download_button(
                label="ðŸ“„ Export Research Report (PDF)",
                data=pdf_bytes,
                file_name=filename,
                mime="application/pdf",
                help="Download the agent response as a PDF file.",
                key=key
            )
            st.markdown("</div>", unsafe_allow_html=True)
        except Exception as e:
            st.error(f"PDF export failed: {e}")
    #else:
        #st.write("No content found in last message.")

        #st.write("Awaiting your request. Click on above button(s) to get the agent's analysis.")
# utils/pdf_export.py

# def render_pdf_download(content, filename="Stock_Analysis.pdf", key=None, user_query=None):
#     # Always append a unique ID to the filename
#     unique_id = uuid.uuid4().hex[:8]
#     base, ext = os.path.splitext(filename)
#     filename = f"{base}_{unique_id}{ext or '.pdf'}"
#     if content:
#         try:
#             if user_query:
#                 pdf_content = (
#                     "# User Query\n"
#                     f"{user_query}\n"
#                     "##########\n\n"
#                     "# Agent Response\n"
#                     f"{content}\n"
#                     "******************\n"
#                 )
#             else:
#                 pdf_content = content
#             pdf_bytes = create_pdf(pdf_content)
#             st.markdown(
#                 """
#                 <div style="display: flex; justify-content: center; align-items: center;">
#                 """,
#                 unsafe_allow_html=True
#             )
#             st.download_button(
#                 label="ðŸ“„ Download as PDF",
#                 data=pdf_bytes,
#                 file_name=filename,
#                 mime="application/pdf",
#                 help="Download the agent response as a PDF file.",
#                 key=key
#             )
#             st.markdown("</div>", unsafe_allow_html=True)
#         except Exception as e:
#             st.error(f"PDF export failed: {e}")
#     else:
#         st.write("No content found in last message.")


# Python
import pandas as pd
from fpdf import FPDF

# Python
# Python
def parse_table_from_text(content: str) -> pd.DataFrame:
    import re
    import pandas as pd

    # Try markdown table (pipes)
    lines = [line.strip() for line in content.splitlines() if "|" in line]
    if lines:
        # Remove separator lines
        lines = [line for line in lines if not re.match(r"^\|\s*-+\s*\|", line)]
        rows = [[cell.strip() for cell in line.strip("|").split("|")] for line in lines]
    else:
        # Try tab-separated
        lines = [line.strip() for line in content.splitlines() if "\t" in line]
        if lines:
            rows = [line.split("\t") for line in lines]
        else:
            # Try space-separated (at least two columns)
            lines = [line.strip() for line in content.splitlines() if re.search(r"\s{2,}", line)]
            rows = [re.split(r"\s{2,}", line) for line in lines]

    if not rows:
        return pd.DataFrame()

    # Normalize columns
    max_cols = max(len(r) for r in rows)
    rows = [r + [""] * (max_cols - len(r)) for r in rows]

    header = rows[0]
    data_rows = rows[1:]
    df = pd.DataFrame(data_rows, columns=header)
    return df

def dataframe_to_pdf(df: pd.DataFrame) -> bytes:
    # Render DataFrame as PDF table
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=10)
    col_width = pdf.w / (len(df.columns) + 1)
    row_height = pdf.font_size * 1.5

    # Header
    for col in df.columns:
        pdf.cell(col_width, row_height, col, border=1)
    pdf.ln(row_height)

    # Rows
    for _, row in df.iterrows():
        for item in row:
            pdf.cell(col_width, row_height, str(item), border=1)
        pdf.ln(row_height)

    return pdf.output(dest="S").encode("latin1")

def create_pdf_from_table_text(content: str) -> bytes:
    df = parse_table_from_text(content)
    if not df.empty:
        return dataframe_to_pdf(df)
    else:
        # fallback to markdown/latex logic
        return create_pdf(content)